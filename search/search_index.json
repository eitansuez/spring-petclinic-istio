{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>A great deal of \"cruft\" accumulates inside many files in <code>spring-petclinic-cloud</code>: configuration for service discovery, load balancing, routing, retries, resilience, and so on.</p> <p>When you move to Istio, you get separation of concerns.  It's ironic that the Spring framework's raison d'\u00eatre was separation of concerns, but its focus is inside a monolithic application, not between microservices.  When you move to cloud-native applications, you end up with a tangle of concerns that Istio helps you untangle.</p> <p>And, little by little, our apps become sane again.  It reminds me of one of Antoine de Saint-Exup\u00e9ry's famous quotes, that perfection is finally attained not when there is no longer anything to add, but when there is no longer anything to take away.</p> <p>The following instructions will walk you through deploying <code>spring-petclinic-istio</code> either using a local Kubernetes cluster or a remote, cloud-based cluster.</p> <p>After the application is deployed, I walk you through some aspects of the application and additional benefits gained from running on the Istio platform:  orthogonal configuration of traffic management and resilience concerns, stronger security and workload identity, and observability.</p>"},{"location":"api/","title":"API Endpoints","text":"<p>Below, we demonstrate calling endpoints on the application in either of two ways:</p> <ol> <li>Internally from within the Kubernetes cluster</li> <li> <p>Through the \"front door\", via the ingress gateway</p> <p>The environment variable <code>LB_IP</code> captures the public IP address of the load balancer fronting the ingress gateway.  We can access the service endpoints through that IP address.</p> </li> </ol>"},{"location":"api/#deploy-the-sleep-client","title":"Deploy the <code>sleep</code> client","text":"<p>We make use of Istio's sleep sample application to facilitate the task of making calls to workloads from inside the cluster.</p> <p>The <code>sleep</code> deployment is a blank client Pod that can be used to send direct calls to specific microservices from within the Kubernetes cluster.</p> <p>Deploy <code>sleep</code> to your cluster:</p> <pre><code>kubectl apply -f manifests/sleep.yaml\n</code></pre> <p>Wait for the sleep pod to be ready (2/2 containers).</p>"},{"location":"api/#test-individual-service-endpoints","title":"Test individual service endpoints","text":""},{"location":"api/#call-the-vets-controller-endpoint","title":"Call the \"Vets\" controller endpoint","text":"InternalExternal <pre><code>kubectl exec deploy/sleep -- curl -s vets-service:8080/vets | jq\n</code></pre> <pre><code>curl -s http://$LB_IP/api/vet/vets | jq\n</code></pre>"},{"location":"api/#customers-service-endpoints","title":"Customers service endpoints","text":"<p>Here are a couple of <code>customers-service</code> endpoints to test:</p> InternalExternal <pre><code>kubectl exec deploy/sleep -- curl -s customers-service:8080/owners | jq\n</code></pre> <pre><code>kubectl exec deploy/sleep -- curl -s customers-service:8080/owners/1/pets/1 | jq\n</code></pre> <pre><code>curl -s http://$LB_IP/api/customer/owners | jq\n</code></pre> <pre><code>curl -s http://$LB_IP/api/customer/owners/1/pets/1 | jq\n</code></pre> <p>Give the owner George Franklin a new pet, Sir Hiss (a snake):</p> InternalExternal <pre><code>kubectl exec deploy/sleep -- curl -s \\\n  -X POST -H 'Content-Type: application/json' \\\n  customers-service:8080/owners/1/pets \\\n  -d '{ \"name\": \"Sir Hiss\", \"typeId\": 4, \"birthDate\": \"2020-01-01\" }'\n</code></pre> <pre><code>curl -X POST -H 'Content-Type: application/json' \\\n  http://$LB_IP/api/customer/owners/1/pets \\\n  -d '{ \"name\": \"Sir Hiss\", \"typeId\": 4, \"birthDate\": \"2020-01-01\" }'\n</code></pre> <p>This can also be performed directly from the UI.</p>"},{"location":"api/#the-visits-service","title":"The Visits service","text":"<p>Test one of the <code>visits-service</code> endpoints:</p> InternalExternal <pre><code>kubectl exec deploy/sleep -- curl -s visits-service:8080/pets/visits?petId=8 | jq\n</code></pre> <pre><code>curl -s http://$LB_IP/api/visit/pets/visits?petId=8 | jq\n</code></pre>"},{"location":"api/#petclinic-frontend","title":"PetClinic Frontend","text":"<p>Call <code>petclinic-frontend</code> endpoint that calls both the customers and visits services:</p> InternalExternal <pre><code>kubectl exec deploy/sleep -- curl -s petclinic-frontend:8080/api/gateway/owners/6 | jq\n</code></pre> <pre><code>curl -s http://$LB_IP/api/gateway/owners/6 | jq\n</code></pre>"},{"location":"deploy/","title":"Build and Deploy PetClinic","text":""},{"location":"deploy/#deploy-each-microservices-backing-database","title":"Deploy each microservice's backing database","text":"<p>Deployment decisions:</p> <ul> <li>We use mysql.  Mysql can be installed with helm.  Its charts are in the bitnami repository.</li> <li>We deploy a separate database statefulset for each service</li> <li>Inside each statefulset we name the database \"service_instance_db\"</li> <li>Apps use the root username \"root\"</li> <li>The helm installation will generate a root user password in a secret</li> <li>The applications reference the secret name to get at the db credentials</li> </ul>"},{"location":"deploy/#preparatory-steps","title":"Preparatory steps","text":"<ol> <li>Add the helm repository:</li> </ol> <pre><code>helm repo add bitnami https://charts.bitnami.com/bitnami\n</code></pre> <ol> <li>Update it:</li> </ol> <pre><code>helm repo update\n</code></pre>"},{"location":"deploy/#deploy-the-databases","title":"Deploy the databases","text":"<p>Now we're ready to deploy the databases with a <code>helm install</code> command for each app/service:</p> <ol> <li> <p>Vets:</p> <pre><code>helm install vets-db-mysql bitnami/mysql --set auth.database=service_instance_db\n</code></pre> </li> <li> <p>Visits:</p> <pre><code>helm install visits-db-mysql bitnami/mysql --set auth.database=service_instance_db\n</code></pre> </li> <li> <p>Customers:</p> <pre><code>helm install customers-db-mysql bitnami/mysql --set auth.database=service_instance_db\n</code></pre> </li> </ol> <p>Wait for the pods to be ready (2/2 containers).</p>"},{"location":"deploy/#build-the-apps-create-the-docker-images-push-them-to-the-local-registry","title":"Build the apps, create the docker images, push them to the local registry","text":"<ol> <li> <p>Compile the apps and run the tests:</p> <pre><code>mvn clean package\n</code></pre> </li> <li> <p>Build the images</p> <pre><code>mvn spring-boot:build-image\n</code></pre> </li> <li> <p>Publish the images</p> <pre><code>./push-images.sh\n</code></pre> </li> </ol>"},{"location":"deploy/#deploy-the-apps","title":"Deploy the apps","text":"<p>The deployment manifests are located in <code>manifests/deploy</code>.</p> <p>The services are <code>vets</code>, <code>visits</code>, <code>customers</code>, and <code>petclinic-frontend</code>.  For each service we create a Kubernetes Service Account, a Deployment, and a ClusterIP service.</p> <p>Apply the deployment manifests:</p> <pre><code>cat manifests/deploy/*.yaml | envsubst | kubectl apply -f -\n</code></pre> <p>Wait for the pods to be ready (2/2 containers).</p>"},{"location":"deploy/#test-database-connectivity","title":"Test database connectivity","text":"<p>Connect directly to the <code>vets-db-mysql</code> database:</p> <pre><code>MYSQL_ROOT_PASSWORD=$(kubectl get secret --namespace default vets-db-mysql -o jsonpath=\"{.data.mysql-root-password}\" | base64 -d)\n</code></pre> <pre><code>kubectl run vets-db-mysql-client \\\n  --rm --tty -i --restart='Never' \\\n  --image docker.io/bitnami/mysql:8.0.36-debian-11-r2 \\\n  --namespace default \\\n  --env MYSQL_ROOT_PASSWORD=$MYSQL_ROOT_PASSWORD \\\n  --command -- bash\n</code></pre> <pre><code>mysql -h vets-db-mysql.default.svc.cluster.local -uroot -p\"$MYSQL_ROOT_PASSWORD\"\n</code></pre> <p>At the mysql prompt, can select the database, show tables, and query records:</p> <pre><code>use service_instance_db;\nshow tables;\nselect * from vets;\n</code></pre> <p>Exit with <code>\\q</code> then <code>exit</code>.</p> <p>One can similarly access the other two databases <code>customers-db-mysql</code> and <code>visits-db-mysql</code>.</p>"},{"location":"deploy/#analysis","title":"Analysis","text":"<p>Prior to Istio, the common solution in the Spring ecosystem to issues of service discovery, resilience, load balancing was Spring Cloud.  Spring Cloud consists of multiple projects that provide dependencies that developers add to their applications to help them deal with issues of client-side load-balancing, retries, circuit-breaking, service discovery and so on.</p> <p>In <code>spring-petclinic-istio</code>, those dependencies have been removed.  What remains as dependencies inside each service are what you'd expect to find:</p> <ul> <li>Spring boot and actuator are the foundation of modern Spring applications</li> <li>Spring data jpa and the mysql connector for database access</li> <li>micrometer for exposing application metrics via a Prometheus endpoint</li> <li>micrometer-tracing for propagating trace headers through these applications</li> </ul>"},{"location":"ingress/","title":"Configure Ingress","text":""},{"location":"ingress/#ingress-gateway-configuration-and-routing","title":"Ingress Gateway configuration and routing","text":"<p>The original project made use of the Spring Cloud Gateway project to configure ingress and routing.</p> <p>Ingress is Istio's bread and butter.  Envoy provides those capabilities.  And so the dependency was removed and replaced with a standard Istio Ingress Gateway.</p> <p>The Istio installation from earlier includes the Ingress Gateway component.  You should be able to see the deployment in the <code>istio-system</code> namespace with:</p> <pre><code>kubectl get deploy -n istio-system\n</code></pre>"},{"location":"ingress/#configure-the-gateway","title":"Configure the Gateway","text":"<pre><code>kubectl apply -f manifests/ingress/gateway.yaml\n</code></pre> <p>The above configuration creates a listener on the ingress gateway for HTTP traffic on port 80.</p> <p>Since no routing has been configured yet for the gateway, a request to the gateway should return an HTTP 404 response:</p> <pre><code>curl -v http://$LB_IP/\n</code></pre>"},{"location":"ingress/#configure-routing","title":"Configure routing","text":"<p>The original Spring Cloud Gateway routing rules were replaced and are now captured with a standard Istio VirtualService CRD in <code>manifests/ingress/routes.yaml</code>.</p> <p>Apply the routing rules for the gateway:</p> <pre><code>kubectl apply -f manifests/ingress/routes.yaml\n</code></pre> <p><code>routes.yaml</code> configures routing for the Istio ingress gateway (which replaces spring cloud gateway) to the application's API endpoints.</p> <p>It exposes endpoints to each of the services, and in addition, routes requests with the <code>/api/gateway</code> prefix to the <code>petclinic-frontend</code> application.  In the original version, the petclinic-frontend application and the gateway \"proper\" were bundled together as a single microservice.</p>"},{"location":"ingress/#visit-the-app","title":"Visit the app","text":"<p>With the application deployed, and ingress configured, we can finally view the application's user interface.</p> <p>To see the running PetClinic application, open a browser tab and visit http://$LB_IP/.</p> <p>You should see a home page.  Navigate to the Vets page, then the Pet Owners page, and finally, drill down to a specific pet owner, and otherwise get acquainted with the UI.</p>"},{"location":"observability/","title":"Observability","text":""},{"location":"observability/#observe-distributed-traces","title":"Observe Distributed Traces","text":"<p>All boot apps are configured to propagate trace headers using micrometer-tracing, per the Istio documentation.</p> <p>See the <code>application.yaml</code> resource files and the property <code>management.tracing.baggage.remote-fields</code> which configures the fields to propagate.</p> <p>To make testing this easier, Istio is configured with 100% trace sampling.</p>"},{"location":"observability/#steps","title":"Steps","text":"<ol> <li> <p>Navigate to the base directory of your Istio distribution:</p> <pre><code>cd istio-1.20.2\n</code></pre> </li> <li> <p>Deploy Istio observability samples:</p> <pre><code>kubectl apply -f samples/addons/prometheus.yaml\nkubectl apply -f samples/addons/jaeger.yaml\nkubectl apply -f samples/addons/kiali.yaml\nkubectl apply -f samples/addons/grafana.yaml\n</code></pre> <p>Wait for the observability pods to be ready:</p> <pre><code>kubectl get pod -n istio-system\n</code></pre> </li> <li> <p>Call the <code>petclinic-frontend</code> endpoint that calls both the customers and visits services, perhaps a two or three times so that the requests get sampled:</p> <pre><code>curl -s http://$LB_IP/api/gateway/owners/6 | jq\n</code></pre> </li> <li> <p>Start the jaeger dashboard:</p> <pre><code>istioctl dashboard jaeger\n</code></pre> </li> <li> <p>In Jaeger, search for traces involving the services petclinic-frontend, customers, and visits.</p> </li> </ol> <p>You should see new traces, with six spans, showing the full end-to-end request-response flow across all three services.</p> <p></p> <p>Close the jaeger dashboard.</p>"},{"location":"observability/#kiali","title":"Kiali","text":"<p>The Kiali dashboard can likewise be used to display visualizations of such end-to-end flows.</p> <ol> <li> <p>Send a light load of requests against your application.</p> <p>We provide a simple siege script to send requests through to the <code>petclinic-frontend</code> endpoint that aggregates responses from both <code>customers</code> and <code>visits</code> services.</p> <pre><code>./siege.sh\n</code></pre> </li> <li> <p>Launch the Kiali dashboard:</p> <pre><code>istioctl dashboard kiali\n</code></pre> </li> </ol> <p>Select the Graph view and the <code>default</code> namespace.  The flow of requests through the applications call graph will be rendered.</p>"},{"location":"observability/#exposing-metrics","title":"Exposing metrics","text":"<p>Istio has built-in support for Prometheus as a mechanism for metrics collection.</p> <p>Each Spring Boot application is configured with a micrometer dependency to expose a scrape endpoint for Prometheus to collect metrics.</p> <p>Call the scrape endpoint and inspect the metrics exposed directly by the Spring Boot application:</p> <pre><code>kubectl exec deploy/customers-v1 -c istio-proxy -- curl -s localhost:8080/actuator/prometheus\n</code></pre> <p>Separately, Envoy collects a variety of metrics, often referred to as RED metrics (Requests, Errors, Durations).</p> <p>Inspect the metrics collected and exposed by the Envoy sidecar:</p> <pre><code>kubectl exec deploy/customers-v1 -c istio-proxy -- curl -s localhost:15090/stats/prometheus\n</code></pre> <p>One common metric to note is <code>istio_requests_total</code></p> <pre><code>kubectl exec deploy/customers-v1 -c istio-proxy -- curl -s localhost:15090/stats/prometheus | grep istio_requests_total\n</code></pre> <p>Both sets of metrics are aggregated (merged) and exposed on port 15020:</p> <pre><code>kubectl exec deploy/customers-v1 -c istio-proxy -- curl -s localhost:15020/stats/prometheus\n</code></pre> <p>For this to work, Envoy must be given the URL (endpoint) where the application's metrics are exposed.</p> <p>This is done with a set of annotations on the deployment.</p> <p>See the Istio documentation for more information.</p>"},{"location":"observability/#viewing-the-istio-grafana-metrics-dashboards","title":"Viewing the Istio Grafana metrics dashboards","text":"<p>Launch the grafana dashboard, while maintaining a request load against the application.</p> <pre><code>./siege.sh\n</code></pre> <p>Then:</p> <pre><code>istioctl dash grafana\n</code></pre> <p>Review the Istio Service Dashboards for the three services <code>petclinic-frontend</code>, <code>customers</code>, and <code>visits</code>.</p> <p>You can also load the legacy dashboard that came with the petclinic application.  You'll find the Grafana dashboard definition (a json file) here.  Import the dashboard and then view it.</p> <p>This dashboard has a couple of now-redundant panels showing the request volume and latencies, both of which are now subsumed by standard Istio dashboards.</p> <p>But it also shows business metrics exposed by the application.  Metrics such as number of owners, pets, and visits created or updated.</p>"},{"location":"resilience/","title":"Resilience","text":""},{"location":"resilience/#test-resilience-and-fallback","title":"Test resilience and fallback","text":"<p>The original Spring Cloud version of PetClinic used Resilience4j to configure calls to the visit service with a timeout of 4 seconds, and a fallback to return an empty list of visits in the event that the request to get visits timed out (took longer).</p> <p>Spring Cloud was removed.  We can replace this configuration with an Istio Custom Resource.</p> <p>The file <code>timeouts.yaml</code> configures the equivalent 4s timeout on requests to the <code>visits</code> service, replacing the previous Resilience4j-based implementation.</p> <p>Apply the timeout configuration to your cluster:</p> <pre><code>kubectl apply -f manifests/config/timeouts.yaml\n</code></pre> <p>The fallback logic in <code>PetClinicController.getOwnerDetails</code> was retrofitted to detect the Gateway Timeout (504) response code instead of using a Resilience4j API.</p> <p>To test this feature, the environment variable DELAY_MILLIS was introduced into the visits service to insert a delay when fetching visits.</p> <p>Here is how to test the behavior:</p> <ol> <li> <p>Call <code>visits-service</code> directly:</p> <pre><code>kubectl exec deploy/sleep -- curl -s visits-service:8080/pets/visits?petId=8 | jq\n</code></pre> <p>Observe the call succeed and return a list of visits for this particular pet.</p> </li> <li> <p>Call the <code>petclinic-frontend</code> endpoint, and note that for each pet, we see a list of visits:</p> <pre><code>kubectl exec deploy/sleep -- curl -s petclinic-frontend:8080/api/gateway/owners/6 | jq\n</code></pre> </li> <li> <p>Edit the deployment manifest for the <code>visits-service</code> so that the environment variable <code>DELAY_MILLIS</code> is set to the value \"5000\" (which is 5 seconds).  One way to do this is to edit the file with (then save and exit):</p> <pre><code>kubectl edit deploy visits-v1\n</code></pre> </li> <li> <p>Once the new <code>visits-service</code> pod reaches Ready status, make the same call again:</p> <pre><code>kubectl exec deploy/sleep -- curl -v visits-service:8080/pets/visits?petId=8 | jq\n</code></pre> <p>Observe the 504 (Gateway timeout) response this time around (because it exceeds the 4-second timeout).</p> </li> <li> <p>Call the <code>petclinic-frontend</code> endpoint once more, and note that for each pet, the list of visits is empty:</p> <pre><code>kubectl exec deploy/sleep -- curl -s petclinic-frontend:8080/api/gateway/owners/6 | jq\n</code></pre> <p>That is, the call succeeds, the timeout is caught, and the fallback empty list of visits is returned in its place. Tail the logs of <code>petclinic-frontend</code> and observe a log message indicating the fallback was triggered.</p> </li> </ol> <p>To restore the original behavior with no delay, edit the <code>visits-v1</code> deployment again and set the environment variable value to \"0\".</p>"},{"location":"security/","title":"Security","text":""},{"location":"security/#leverage-workload-identity","title":"Leverage workload identity","text":"<p>Workloads in Istio are assigned a SPIFFE identity.</p> <p>Authorization policies can be applied that allow or deny access to a service as a function of that identity.</p> <p>For example, we can restrict access to each database exclusively to its corresponding service, i.e.:</p> <ul> <li>Only the visits service can access the visits db</li> <li>Only the vets service can access the vets db</li> <li>Only the customers service can access the customers db</li> </ul> <p>The above policy is specified in the file <code>authorization-policies.yaml</code>.</p>"},{"location":"security/#exercise","title":"Exercise","text":"<ol> <li> <p>Use the previous Test database connectivity instructions to create a client pod and to use it to connect to the \"vets\" database.  This operation should succeed.  You should be able to see the \"service_instance_db\" and see the tables and query them.</p> </li> <li> <p>Apply the authorization policies:</p> <pre><code>kubectl apply -f manifests/config/authorization-policies.yaml\n</code></pre> </li> <li> <p>Attempt once more to create a client pod to connect to the \"vets\" database.  This time the operation will fail.  That's because only the vets service is now allowed to connect to the database.</p> </li> <li> <p>Also verify that the application itself continues to function because all database queries are performed via its associated service.</p> </li> </ol>"},{"location":"setup/","title":"Setup","text":"<p>Below are two main options for environments.</p>"},{"location":"setup/#kubernetes","title":"Kubernetes","text":"Local SetupRemote Setup <p>On a Mac running Docker Desktop or Rancher Desktop, make sure to give your VM plenty of CPU and memory. 16GB of memory and 6 CPUs seems to work for me.</p> <p>Deploy a local K3D Kubernetes cluster with a local registry:</p> <pre><code>k3d cluster create my-istio-cluster \\\n  --api-port 6443 \\\n  --k3s-arg \"--disable=traefik@server:0\" \\\n  --port 80:80@loadbalancer \\\n  --registry-create my-cluster-registry:0.0.0.0:5010\n</code></pre> <p>Above, we: - Disable the default traefik load balancer and configure local port 80 to instead forward to the \"istio-ingressgateway\" load balancer. - Create a registry we can push to locally on port 5010 that is accessible from the Kubernetes cluster at \"my-cluster-registry:5000\".</p> <p>Provision a k8s cluster in the cloud of your choice.  For example, on GCP:</p> <pre><code>gcloud container clusters create my-istio-cluster \\\n  --cluster-version latest \\\n  --machine-type \"e2-standard-2\" \\\n  --num-nodes \"3\" \\\n  --network \"default\"\n</code></pre>"},{"location":"setup/#environment-variables","title":"Environment variables","text":"<p>Use the file <code>envrc-template.sh</code> as the basis for configuring environment variables.</p> <p>Be sure to:</p> <ol> <li>Set the local variable <code>local_setup</code> to either \"true\" or \"false\", depending on your choice of a local or remote cluster.</li> <li>If using a remote setup, set the value of PUSH_IMAGE_REGISTRY to the value of your image registry URL.</li> </ol> <p>I highly recommend using <code>direnv</code>, a convenient way of associating the setting environment variables to entering a specific directory.</p> <p>If you choose to use <code>direnv</code>, then the variables can be automatically set by renaming the file to <code>.envrc</code> and running the command <code>direnv allow</code>.</p>"},{"location":"setup/#deploy-istio","title":"Deploy Istio","text":"<ol> <li> <p>Follow the Istio documentation's instructions to download Istio.</p> </li> <li> <p>Once the <code>istioctl</code> CLI has been added to your path, run the following installation command:</p> <pre><code>istioctl install -f manifests/istio-install-manifest.yaml\n</code></pre> </li> </ol> <p>The above-referenced configuration manifest configures certain facets of the mesh, namely:</p> <ol> <li>Setting trace sampling at 100%, for ease of obtaining distributed traces</li> <li>Deploying sidecars (envoy proxies) not only alongside workloads, but also in front of mysql databases.</li> </ol> <p>Once Istio is installed, feel free to verify the installation with:</p> <pre><code>istioctl verify-install\n</code></pre> <p>In the next section, you will work on deploying the microservices to the <code>default</code> namespace.</p> <p>As a final step, label the <code>default</code> namespace for sidecar injection with:</p> <pre><code>kubectl label ns default istio-injection=enabled\n</code></pre>"}]}