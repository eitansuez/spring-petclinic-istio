{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>A great deal of \"cruft\" accumulates inside many files in <code>spring-petclinic-cloud</code>: configuration for service discovery, load balancing, routing, retries, resilience, and so on.</p> <p>When you move to Istio, you get separation of concerns.  It's ironic that the Spring framework's raison d'\u00eatre was separation of concerns, but its focus is inside a monolithic application, not between microservices.  When you move to cloud-native applications, you end up with a tangle of concerns that Istio helps you untangle.</p> <p>And, little by little, our apps become sane again.  It reminds me of one of Antoine de Saint-Exup\u00e9ry's famous quotes:</p> <p>Perfection is finally attained not when there is no longer anything to add, but when there is no longer anything to take away</p> <p>The following instructions will walk you through deploying <code>spring-petclinic-istio</code> either using a local Kubernetes cluster or a remote, cloud-based cluster.</p> <p>After the application is deployed, I walk you through some aspects of the application and additional benefits gained from running on the Istio platform:  orthogonal configuration of traffic management and resilience concerns, stronger security and workload identity, and observability.</p> <p>Let's get started..</p>"},{"location":"api/","title":"API Endpoints","text":"<p>Below, we demonstrate calling endpoints on the application in either of two ways:</p> <ol> <li>Internally from within the Kubernetes cluster</li> <li> <p>Through the \"front door\", via the ingress gateway</p> <p>The environment variable <code>LB_IP</code> captures the public IP address of the load balancer fronting the ingress gateway.  We can access the service endpoints through that IP address.</p> </li> </ol>"},{"location":"api/#deploy-the-sleep-client","title":"Deploy the <code>sleep</code> client","text":"<p>We make use of Istio's sleep sample application to facilitate the task of making calls to workloads from inside the cluster.</p> <p>The <code>sleep</code> deployment is a blank client Pod that can be used to send direct calls to specific microservices from within the Kubernetes cluster.</p> <p>Deploy <code>sleep</code> to your cluster:</p> <pre><code>kubectl apply -f manifests/sleep.yaml\n</code></pre> <p>Wait for the sleep pod to be ready (2/2 containers).</p>"},{"location":"api/#test-individual-service-endpoints","title":"Test individual service endpoints","text":"<p>We assume that you have the excellent jq utility already installed.</p>"},{"location":"api/#call-the-vets-controller-endpoint","title":"Call the \"Vets\" controller endpoint","text":"InternalExternal <pre><code>kubectl exec deploy/sleep -- curl -s vets-service:8080/vets | jq\n</code></pre> <pre><code>curl -s http://$LB_IP/api/vet/vets | jq\n</code></pre>"},{"location":"api/#customers-service-endpoints","title":"Customers service endpoints","text":"<p>Here are a couple of <code>customers-service</code> endpoints to test:</p> InternalExternal <pre><code>kubectl exec deploy/sleep -- curl -s customers-service:8080/owners | jq\n</code></pre> <pre><code>kubectl exec deploy/sleep -- curl -s customers-service:8080/owners/1/pets/1 | jq\n</code></pre> <pre><code>curl -s http://$LB_IP/api/customer/owners | jq\n</code></pre> <pre><code>curl -s http://$LB_IP/api/customer/owners/1/pets/1 | jq\n</code></pre> <p>Give the owner George Franklin a new pet, Sir Hiss (a snake):</p> InternalExternal <pre><code>kubectl exec deploy/sleep -- curl -s -v \\\n  -X POST -H 'Content-Type: application/json' \\\n  customers-service:8080/owners/1/pets \\\n  -d '{ \"name\": \"Sir Hiss\", \"typeId\": 4, \"birthDate\": \"2020-01-01\" }'\n</code></pre> <pre><code>curl -v -X POST -H 'Content-Type: application/json' \\\n  http://$LB_IP/api/customer/owners/1/pets \\\n  -d '{ \"name\": \"Sir Hiss\", \"typeId\": 4, \"birthDate\": \"2020-01-01\" }'\n</code></pre> <p>This can also be performed directly from the UI.</p>"},{"location":"api/#the-visits-service","title":"The Visits service","text":"<p>Test one of the <code>visits-service</code> endpoints:</p> InternalExternal <pre><code>kubectl exec deploy/sleep -- curl -s visits-service:8080/pets/visits?petId=8 | jq\n</code></pre> <pre><code>curl -s http://$LB_IP/api/visit/pets/visits?petId=8 | jq\n</code></pre>"},{"location":"api/#petclinic-frontend","title":"PetClinic Frontend","text":"<p>Call <code>petclinic-frontend</code> endpoint that calls both the customers and visits services:</p> InternalExternal <pre><code>kubectl exec deploy/sleep -- curl -s petclinic-frontend:8080/api/gateway/owners/6 | jq\n</code></pre> <pre><code>curl -s http://$LB_IP/api/gateway/owners/6 | jq\n</code></pre>"},{"location":"api/#summary","title":"Summary","text":"<p>Now that we have some familiarity with some of the API endpoints that make up this application, let's turn our attention to configuring a small aspect of resilience:  timeouts.</p>"},{"location":"deploy/","title":"Build and Deploy PetClinic","text":""},{"location":"deploy/#deploy-each-microservices-backing-database","title":"Deploy each microservice's backing database","text":"<p>Deployment decisions:</p> <ul> <li>We use mysql.  Mysql can be installed with helm.  Its charts are in the bitnami repository.</li> <li>We deploy a separate database statefulset for each service.</li> <li>Inside each statefulset we name the database \"service_instance_db\".</li> <li>Apps use the root username \"root\".</li> <li>The helm installation will generate a root user password in a secret.</li> <li>The applications reference the secret name to get at the database credentials.</li> </ul>"},{"location":"deploy/#preparatory-steps","title":"Preparatory steps","text":"<p>We assume you already have helm installed.</p> <ol> <li> <p>Add the helm repository:</p> <pre><code>helm repo add bitnami https://charts.bitnami.com/bitnami\n</code></pre> </li> <li> <p>Update it:</p> <pre><code>helm repo update\n</code></pre> </li> </ol>"},{"location":"deploy/#deploy-the-databases","title":"Deploy the databases","text":"<p>Deploy the databases with a <code>helm install</code> command, one for each app/service:</p> <ol> <li> <p>Vets:</p> <pre><code>helm install vets-db-mysql bitnami/mysql --set auth.database=service_instance_db\n</code></pre> </li> <li> <p>Visits:</p> <pre><code>helm install visits-db-mysql bitnami/mysql --set auth.database=service_instance_db\n</code></pre> </li> <li> <p>Customers:</p> <pre><code>helm install customers-db-mysql bitnami/mysql --set auth.database=service_instance_db\n</code></pre> </li> </ol> <p>The databases should be up after ~ 1-2 minutes.</p> <p>Wait for the pods to be ready (2/2 containers).</p>"},{"location":"deploy/#build-the-apps-create-the-docker-images-push-them-to-the-local-registry","title":"Build the apps, create the docker images, push them to the local registry","text":"<p>We assume you already have maven installed locally.</p> <ol> <li> <p>Compile the apps and run the tests:</p> <pre><code>mvn clean package\n</code></pre> </li> <li> <p>Build the images</p> <pre><code>mvn spring-boot:build-image\n</code></pre> </li> <li> <p>Publish the images</p> <pre><code>./push-images.sh\n</code></pre> </li> </ol>"},{"location":"deploy/#deploy-the-apps","title":"Deploy the apps","text":"<p>The deployment manifests are located in <code>manifests/deploy</code>.</p> <p>The services are <code>vets</code>, <code>visits</code>, <code>customers</code>, and <code>petclinic-frontend</code>.  For each service we create a Kubernetes ServiceAccount, a Deployment, and a ClusterIP service.</p> <p>Apply the deployment manifests:</p> <pre><code>cat manifests/deploy/*.yaml | envsubst | kubectl apply -f -\n</code></pre> <p>The manifests reference the image registry environment variable, and so are passed through <code>envsubst</code> for resolution before being applied to the Kubernetes cluster.</p> <p>Wait for the pods to be ready (2/2 containers).</p> <p>Here is a simple diagnostic command that tails the logs of the customers service pod, showing that the Spring Boot application has come up and is listening on port 8080.</p> <pre><code>kubectl logs --follow svc/customers-service\n</code></pre>"},{"location":"deploy/#test-database-connectivity","title":"Test database connectivity","text":"<p>The below instructions are taken from the output from the prior <code>helm install</code> command.</p> <p>Connect directly to the <code>vets-db-mysql</code> database:</p> <ol> <li> <p>Obtain the root password from the Kubernetes secret:</p> bash shellfish shell <pre><code>MYSQL_ROOT_PASSWORD=$(kubectl get secret --namespace default \\\n  vets-db-mysql -o jsonpath=\"{.data.mysql-root-password}\" | base64 -d)\n</code></pre> <pre><code>set MYSQL_ROOT_PASSWORD $(kubectl get secret --namespace default \\\n  vets-db-mysql -o jsonpath=\"{.data.mysql-root-password}\" | base64 -d)\n</code></pre> </li> <li> <p>Create, and shell into a mysql client pod:</p> <pre><code>kubectl run vets-db-mysql-client \\\n  --rm --tty -i --restart='Never' \\\n  --image docker.io/bitnami/mysql:8.0.36-debian-11-r2 \\\n  --namespace default \\\n  --env MYSQL_ROOT_PASSWORD=$MYSQL_ROOT_PASSWORD \\\n  --command -- bash\n</code></pre> </li> <li> <p>Use the <code>mysql</code> client to connect to the database:</p> <pre><code>mysql -h vets-db-mysql.default.svc.cluster.local -uroot -p\"$MYSQL_ROOT_PASSWORD\"\n</code></pre> </li> </ol> <p>At the mysql prompt, select the database, list the tables, and query vet records:</p> <pre><code>use service_instance_db;\n</code></pre> <pre><code>show tables;\n</code></pre> <pre><code>select * from vets;\n</code></pre> <p>Exit the mysql prompt with <code>\\q</code>, then exit the pod with <code>exit</code>.</p> <p>One can similarly connect to and inspect the <code>customers-db-mysql</code> and <code>visits-db-mysql</code> databases.</p>"},{"location":"deploy/#summary","title":"Summary","text":"<p>At this point you should have all applications deployed and running, connected to their respective databases.</p> <p>But we cannot access the application's UI until we configure ingress, which is our next topic.</p>"},{"location":"ingress/","title":"Configure Ingress","text":"<p>The original project made use of the Spring Cloud Gateway project to configure ingress and routing.</p> <p>Ingress is Istio's bread and butter.  Envoy provides those capabilities.  And so the dependency was removed and replaced with a standard Istio Ingress Gateway.</p> <p>The Istio installation includes the Ingress Gateway component.  You should be able to see the deployment in the <code>istio-system</code> namespace with:</p> <pre><code>kubectl get deploy -n istio-system\n</code></pre> <p>Ingress is configured with Istio in two parts:  the gateway configuration proper, and the configuration to route requests to backing services.</p>"},{"location":"ingress/#configure-the-gateway","title":"Configure the Gateway","text":"<p>The below configuration creates a listener on the ingress gateway for HTTP traffic on port 80.</p> gateway.yaml <pre><code>---\napiVersion: networking.istio.io/v1beta1\nkind: Gateway\nmetadata:\n  name: main-gateway\nspec:\n  selector:\n    istio: ingressgateway\n  servers:\n    - port:\n        number: 80\n        name: http\n        protocol: HTTP\n      hosts:\n      - \"*\"\n</code></pre> <p>Apply the gateway configuration to your cluster:</p> <pre><code>kubectl apply -f manifests/ingress/gateway.yaml\n</code></pre> <p>Since no routing has been configured yet for the gateway, a request to the gateway should return an HTTP 404 response:</p> <pre><code>curl -v http://$LB_IP/\n</code></pre>"},{"location":"ingress/#configure-routing","title":"Configure routing","text":"<p>The original Spring Cloud Gateway routing rules were replaced and are now captured with a standard Istio VirtualService in <code>manifests/ingress/routes.yaml</code>:</p> <p><code>routes.yaml</code> configures routing for the Istio ingress gateway (which replaces spring cloud gateway) to the application's API endpoints.</p> <p>It exposes endpoints to each of the services, and in addition, routes requests with the <code>/api/gateway</code> prefix to the <code>petclinic-frontend</code> application.  In the original version, the petclinic-frontend application and the gateway \"proper\" were bundled together as a single microservice.</p> routes.yaml <pre><code>---\napiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: petclinic-routes\nspec:\n  hosts:\n  - \"*\"\n  gateways:\n  - main-gateway\n  http:\n    - match:\n      - uri:\n          prefix: \"/api/customer/\"\n      rewrite:\n        uri: \"/\"\n      route:\n      - destination:\n          host: customers-service.default.svc.cluster.local\n          port:\n            number: 8080\n    - match:\n      - uri:\n          prefix: \"/api/visit/\"\n      rewrite:\n        uri: \"/\"\n      route:\n      - destination:\n          host: visits-service.default.svc.cluster.local\n          port:\n            number: 8080\n      timeout: 4s\n    - match:\n      - uri:\n          prefix: \"/api/vet/\"\n      rewrite:\n        uri: \"/\"\n      route:\n      - destination:\n          host: vets-service.default.svc.cluster.local\n          port:\n            number: 8080\n    - match:\n        - uri:\n            prefix: \"/api/gateway\"\n      route:\n        - destination:\n            host: petclinic-frontend.default.svc.cluster.local\n            port:\n              number: 8080\n    - route:\n        - destination:\n            host: petclinic-frontend.default.svc.cluster.local\n            port:\n              number: 8080\n</code></pre> <p>Apply the routing rules for the gateway:</p> <pre><code>kubectl apply -f manifests/ingress/routes.yaml\n</code></pre>"},{"location":"ingress/#visit-the-app","title":"Visit the app","text":"<p>With the application deployed and ingress configured, we can finally view the application's user interface.</p> <p>To see the running PetClinic application, open a browser tab and visit http://$LB_IP/.</p> <p>You should see a home page.  Navigate to the Vets page, then the Pet Owners page, and finally, drill down to a specific pet owner, and otherwise get acquainted with the UI.</p>"},{"location":"ingress/#analysis","title":"Analysis","text":"<p>Prior to Istio, the common solution in the Spring ecosystem to issues of service discovery, resilience, load balancing was Spring Cloud.  Spring Cloud consists of multiple projects that provide dependencies that developers add to their applications to help them deal with issues of client-side load-balancing, retries, circuit-breaking, service discovery and so on.</p> <p>In <code>spring-petclinic-istio</code>, those dependencies have been removed.  What remains as dependencies inside each service are what you'd expect to find:</p> <ul> <li>Spring Boot and actuator are the foundation of modern Spring applications.</li> <li>Spring Data JPA and the mysql connector for database access.</li> <li>Micrometer for exposing application metrics via a Prometheus endpoint.</li> <li>Micrometer-tracing for propagating trace headers through these applications.</li> </ul>"},{"location":"observability/","title":"Observability","text":""},{"location":"observability/#distributed-tracing","title":"Distributed Tracing","text":"<p>The Istio documentation dedicates a page to guide users on how to propagate trace headers in calls between microservices, in order to support distributed tracing.</p> <p>In this version of PetClinic, all Spring Boot microservices have been configured to propagate trace headers using micrometer-tracing.</p> <p>Micrometer tracing is an elegant solution, in that we do not have to couple the trace header propagation with the application logic.  Instead, it becomes a simple matter of static configuration.</p> <p>See the <code>application.yaml</code> resource files and the property <code>management.tracing.baggage.remote-fields</code> which configures the fields to propagate.</p> <p>To make testing this easier, Istio is configured with 100% trace sampling.</p>"},{"location":"observability/#observe-distributed-traces","title":"Observe distributed traces","text":"<p>In its <code>samples</code> directory, Istio provides sample deployment manifests for various observability tools, including Zipkin and Jaeger.</p> <p>Deploy Jaeger to your Kubernetes cluster:</p> <ol> <li> <p>Navigate to the base directory of your Istio distribution:</p> <pre><code>cd istio-1.20.2\n</code></pre> </li> <li> <p>Deploy jaeger:</p> <pre><code>kubectl apply -f samples/addons/jaeger.yaml\n</code></pre> </li> <li> <p>Wait for the Jaeger pod to be ready:</p> <pre><code>kubectl get pod -n istio-system\n</code></pre> </li> </ol> <p>Next, let us turn our attention to calling an endpoint that will generate a trace capture, and observe it in the Jaeger dashboard:</p> <ol> <li> <p>Call the <code>petclinic-frontend</code> endpoint that calls both the <code>customers</code> and <code>visits</code> services.  Feel free to make mulitple requests to generate multiple traces.</p> <pre><code>curl -s http://$LB_IP/api/gateway/owners/6 | jq\n</code></pre> </li> <li> <p>Launch the jaeger dashboard:</p> <pre><code>istioctl dashboard jaeger\n</code></pre> </li> <li> <p>In Jaeger, search for traces involving the services <code>petclinic-frontend</code>, <code>customers</code>, and <code>visits</code>.</p> </li> </ol> <p>You should see one or more traces, each with six spans.  Click on any one of them to display the full end-to-end request-response flow across all three services.</p> <p></p> <p>Close the Jaeger dashboard.</p>"},{"location":"observability/#exposing-metrics","title":"Exposing metrics","text":"<p>Istio has built-in support for Prometheus as a mechanism for metrics collection.</p> <p>Each Spring Boot application is configured with a micrometer dependency to expose a scrape endpoint for Prometheus to collect metrics.</p> <p>Call the scrape endpoint and inspect the metrics exposed directly by the Spring Boot application:</p> <pre><code>kubectl exec deploy/customers-v1 -c istio-proxy -- curl -s localhost:8080/actuator/prometheus\n</code></pre> <p>Separately, Envoy collects a variety of metrics, often referred to as RED metrics, for: Requests, Errors, and Durations.</p> <p>Inspect the metrics collected and exposed by the Envoy sidecar:</p> <pre><code>kubectl exec deploy/customers-v1 -c istio-proxy -- curl -s localhost:15090/stats/prometheus\n</code></pre> <p>One common metric to note is the counter <code>istio_requests_total</code>:</p> <pre><code>kubectl exec deploy/customers-v1 -c istio-proxy -- \\\n  curl -s localhost:15090/stats/prometheus | grep istio_requests_total\n</code></pre> <p>Both the application metrics and envoy's metrics are aggregated (merged) and exposed on port 15020:</p> <pre><code>kubectl exec deploy/customers-v1 -c istio-proxy -- curl -s localhost:15020/stats/prometheus\n</code></pre> <p>What allows Istio to aggregate both scrape endpoints are annotations placed in the pod template specification for each application, communicating the URL of the Prometheus scrape endpoint.</p> <p>For example, here are the prometheus annotations for the <code>customers</code> service.</p> <p>For more information on metrics merging and Prometheus, see the Istio documentation.</p>"},{"location":"observability/#send-requests-to-the-application","title":"Send requests to the application","text":"<p>To send a steady stream of requests through the <code>petclinic-frontend</code> application, we use siege.  Feel free to use other tools, or maybe a simple bash <code>while</code> loop.</p> <p>Run the following <code>siege</code> command to send requests to various endpoints in our application:</p> <pre><code>siege --concurrent=6 --delay=2 --file=./urls.txt\n</code></pre> <p>Leave the siege command running.</p> <p>Open a separate terminal in which to run subsequent commands.</p>"},{"location":"observability/#the-prometheus-dashboard","title":"The Prometheus dashboard","text":"<p>Deploy Prometheus to your Kubernetes cluster:</p> <pre><code>kubectl apply -f samples/addons/prometheus.yaml\n</code></pre> <p>The latest version of Spring Boot (3.2) takes advantage of a relatively recent feature of Prometheus known as \"exemplars.\"  The current version of Istio uses an older version of Prometheus (2.41) that does not yet support exemplars.</p> <p>Before deploying Prometheus, patch the prometheus deployment to use the latest version of the image:</p> <pre><code>kubectl patch deploy -n istio-system prometheus --patch-file=manifests/config/prom-patch.yaml\n</code></pre> <p>Launch the Prometheus dashboard:</p> <pre><code>istioctl dash prometheus\n</code></pre> <p>Here are some PromQL queries you can try out, that will fetch metrics from Prometheus' metrics store:</p> <ol> <li> <p>The number of requests made by <code>petclinic-frontend</code> to the <code>cutomers</code> service:</p> <pre><code>istio_requests_total{source_app=\"petclinic-frontend\",destination_app=\"customers-service\",reporter=\"source\"}\n</code></pre> </li> <li> <p>A business metric exposed by the application proper:  the number of calls to the <code>findPet</code> method:</p> <pre><code>petclinic_pet_seconds_count{method=\"findPet\"}\n</code></pre> </li> </ol>"},{"location":"observability/#istios-grafana-metrics-dashboards","title":"Istio's Grafana metrics dashboards","text":"<p>Istio provides standard service mesh dashboards, based on the standard metrics collected by Envoy and sent to Prometheus.</p> <p>Deploy Grafana:</p> <pre><code>kubectl apply -f samples/addons/grafana.yaml\n</code></pre> <p>Launch the Grafana dashboard:</p> <pre><code>istioctl dash grafana\n</code></pre> <p>Navigate to the dashboards section, you will see an Istio folder.</p> <p>Select the Istio service dashboard.</p> <p>Review the Istio Service Dashboards for the services <code>petclinic-frontend</code>, <code>vets</code>, <code>customers</code>, and <code>visits</code>.</p> <p>The dashboard exposes metrics such as the client request volume, client success rate, and client request durations:</p> <p></p>"},{"location":"observability/#petclinic-custom-grafana-dashboard","title":"PetClinic custom Grafana dashboard","text":"<p>The version of PetClinic from which this version derives already contained a custom Grafana dashboard.</p> <p>To import the dashboard into Grafana:</p> <ol> <li>Navigate to \"Dashboards\"</li> <li>Click the \"New\" pulldown button, and select \"Import\"</li> <li>Select \"Upload dashboard JSON file\", and select the file <code>grafana-petclinic-dashboard.json</code> from the repository's base directory.</li> <li>Select \"Prometheus\" as the data source</li> <li>Finally, click \"Import\"</li> </ol> <p>The top two panels showing request latencies and request volumes are technically now redundant:  both are now subsumed by the standard Istio dashboards.</p> <p>Below those panels are custom application metrics. Metrics such as number of owners, pets, and visits created or updated.</p> <p>Create a new Owner, give an existing owner a new pet, or add a visit for a pet, and watch those counters increment in Grafana.</p>"},{"location":"observability/#kiali","title":"Kiali","text":"<p>Kiali is a bespoke \"console\" for Istio Service Mesh.  One of the features of Kiali that stands out are the visualizations of requests making their way through the call graph.</p> <ol> <li> <p>Cancel the currently-running siege command.  Relaunch siege, but with a different set of target endpoints:</p> <pre><code>siege --concurrent=6 --delay=2 --file=./frontend-urls.txt\n</code></pre> </li> <li> <p>Deploy Kiali:</p> <pre><code>kubectl apply -f samples/addons/kiali.yaml\n</code></pre> </li> <li> <p>Launch the Kiali dashboard:</p> <pre><code>istioctl dashboard kiali\n</code></pre> <p>Select the Graph view and the <code>default</code> namespace.</p> <p>The flow of requests through the applications call graph will be rendered.</p> </li> </ol> <p></p>"},{"location":"resilience/","title":"Resilience","text":"<p>The original Spring Cloud version of PetClinic used Resilience4j to configure calls to the visit service with a timeout of 4 seconds, and a fallback to return an empty list of visits in the event that the request to get visits timed out.</p> <p>In this version of the application, the Spring Cloud dependencies were removed.  We can replace this configuration with an Istio Custom Resource.</p> <p>The file <code>timeouts.yaml</code> configures the equivalent 4s timeout on requests to the <code>visits</code> service, replacing the previous Resilience4j-based implementation.</p> timeouts.yaml <pre><code>---\napiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: visits\nspec:\n  hosts:\n  - visits-service.default.svc.cluster.local\n  http:\n  - route:\n      - destination:\n          host: visits-service.default.svc.cluster.local\n    timeout: 4s\n</code></pre> <p>Apply the timeout configuration to your cluster:</p> <pre><code>kubectl apply -f manifests/config/timeouts.yaml\n</code></pre> <p>The fallback logic in <code>PetClinicController.getOwnerDetails</code> was retrofitted to detect the Gateway Timeout (504) response code instead of using a Resilience4j API.</p> <p>To test this feature, the environment variable DELAY_MILLIS was introduced into the visits service to insert a delay when fetching visits.</p> <p>Here is how to test the behavior:</p> <ol> <li> <p>Call <code>visits-service</code> directly:</p> bash shellfish shell <pre><code>kubectl exec deploy/sleep -- curl -s visits-service:8080/pets/visits?petId=8 | jq\n</code></pre> <pre><code>kubectl exec deploy/sleep -- curl -s visits-service:8080/pets/visits\\?petId=8 | jq\n</code></pre> <p>Observe the call succeed and return a list of visits for this particular pet.</p> </li> <li> <p>Call the <code>petclinic-frontend</code> endpoint, and note that for each pet, we see a list of visits:</p> <pre><code>kubectl exec deploy/sleep -- curl -s petclinic-frontend:8080/api/gateway/owners/6 | jq\n</code></pre> </li> <li> <p>Edit the deployment manifest for the <code>visits-service</code> so that the environment variable <code>DELAY_MILLIS</code> is set to the value \"5000\" (which is 5 seconds).  One way to do this is to edit the file with (then save and exit):</p> <pre><code>kubectl edit deploy visits-v1\n</code></pre> <p>Wait until the new pod has rolled out and become ready.</p> </li> <li> <p>Once the new <code>visits-service</code> pod reaches Ready status, make the same call again:</p> bash shellfish shell <pre><code>kubectl exec deploy/sleep -- curl -v visits-service:8080/pets/visits?petId=8 | jq\n</code></pre> <pre><code>kubectl exec deploy/sleep -- curl -v visits-service:8080/pets/visits\\?petId=8 | jq\n</code></pre> <p>Observe the 504 (Gateway timeout) response this time around (because it exceeds the 4-second timeout).</p> </li> <li> <p>Call the <code>petclinic-frontend</code> endpoint once more, and note that for each pet, the list of visits is empty:</p> <pre><code>kubectl exec deploy/sleep -- curl -s petclinic-frontend:8080/api/gateway/owners/6 | jq\n</code></pre> <p>That is, the call succeeds, the timeout is caught, and the fallback empty list of visits is returned in its place.</p> </li> <li> <p>Tail the logs of <code>petclinic-frontend</code> and observe a log message indicating the fallback was triggered.</p> <pre><code>kubectl logs --follow svc/petclinic-frontend\n</code></pre> </li> </ol> <p>Restore the original behavior with no delay:  edit the <code>visits-v1</code> deployment again and set the environment variable value to \"0\".</p> <p>Let us next turn our attention to security-related configuration.</p>"},{"location":"security/","title":"Security","text":""},{"location":"security/#leverage-workload-identity","title":"Leverage workload identity","text":"<p>Workloads in Istio are assigned a SPIFFE identity.</p> <p>Authorization policies can be applied that allow or deny access to a service as a function of that identity.</p> <p>For example, we can restrict access to each database exclusively to its corresponding service, i.e.:</p> <ul> <li>Only the visits service can access the visits db</li> <li>Only the vets service can access the vets db</li> <li>Only the customers service can access the customers db</li> </ul> <p>The above policy is specified in the file <code>authorization-policies.yaml</code>:</p> authorization-policies.yaml <pre><code>---\napiVersion: security.istio.io/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: vets-db-allow-vets-service\nspec:\n  selector:\n    matchLabels:\n      app.kubernetes.io/instance: vets-db-mysql\n  action: ALLOW\n  rules:\n  - from:\n    - source:\n        principals: [\"cluster.local/ns/default/sa/vets-service\"]\n    to:\n    - operation:\n        ports: [\"3306\"]\n---\napiVersion: security.istio.io/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: customers-db-allow-customers-service\nspec:\n  selector:\n    matchLabels:\n      app.kubernetes.io/instance: customers-db-mysql\n  action: ALLOW\n  rules:\n    - from:\n        - source:\n            principals: [\"cluster.local/ns/default/sa/customers-service\"]\n      to:\n        - operation:\n            ports: [\"3306\"]\n---\napiVersion: security.istio.io/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: visits-db-allow-visits-service\nspec:\n  selector:\n    matchLabels:\n      app.kubernetes.io/instance: visits-db-mysql\n  action: ALLOW\n  rules:\n    - from:\n        - source:\n            principals: [\"cluster.local/ns/default/sa/visits-service\"]\n      to:\n        - operation:\n            ports: [\"3306\"]\n</code></pre> <p>The main aspects of each authorization policy are:</p> <ol> <li>The <code>selector</code> identifies the workload to apply the policy to</li> <li>The <code>action</code> in this case is to Allow requests that match the given rules</li> <li>The <code>rules</code> section which specify the source <code>principal</code>, aka workload identity.</li> <li>The <code>to</code> section applies the policy to requests on port 3306, the port that <code>mysqld</code> listens on.</li> </ol>"},{"location":"security/#exercise","title":"Exercise","text":"<ol> <li> <p>Use the previous \"Test database connectivity\" instructions to create a client pod and to use it to connect to the \"vets\" database.  This operation should succeed.  You should be able to see the \"service_instance_db\" and see the tables and query them.</p> </li> <li> <p>Apply the authorization policies:</p> <pre><code>kubectl apply -f manifests/config/authorization-policies.yaml\n</code></pre> </li> <li> <p>Attempt once more to create a client pod to connect to the \"vets\" database.  This time the operation will fail.  That's because only the vets service is now allowed to connect to the database.</p> </li> <li> <p>Verify that the application itself continues to function because all database queries are performed via its associated service.</p> </li> </ol>"},{"location":"security/#summary","title":"Summary","text":"<p>One problem in the enterprise is enforcing access to data via microservices.  Giving another team direct access to data is a well-known anti-pattern, as it couples multiple applications to a specific storage technology, a specific database schema, one that cannot be allowed to evolve without impacting everyone.</p> <p>With the aid of Istio and workload identity, we can make sure that the manner in which data is stored by a microservice is an entirely internal concern, one that can be modified at a later time, perhaps to use a different storage backend, or perhaps simply to allow for the evolution of the schema without \"breaking all the clients\".</p> <p>After traffic management, resilience, and security, it is time to discuss the other important facet that servicec meshes help with:  Observability.</p>"},{"location":"setup/","title":"Setup","text":"<p>Begin by cloning a local copy of the Spring PetClinic Istio repository from GitHub.</p>"},{"location":"setup/#kubernetes","title":"Kubernetes","text":"<p>Select whether you wish to provision Kubernetes locally or remotely using a cloud provider.</p> Local SetupRemote Setup <p>On a Mac running Docker Desktop or Rancher Desktop, make sure to give your VM plenty of CPU and memory. 16GB of memory and 6 CPUs seems to work for me.</p> <p>Deploy a local K3D Kubernetes cluster with a local registry:</p> <pre><code>k3d cluster create my-istio-cluster \\\n  --api-port 6443 \\\n  --k3s-arg \"--disable=traefik@server:0\" \\\n  --port 80:80@loadbalancer \\\n  --registry-create my-cluster-registry:0.0.0.0:5010\n</code></pre> <p>Above, we:</p> <ul> <li>Disable the default traefik load balancer and configure local port 80 to instead forward to the \"istio-ingressgateway\" load balancer.</li> <li>Create a registry we can push to locally on port 5010 that is accessible from the Kubernetes cluster at \"my-cluster-registry:5000\".</li> </ul> <p>Provision a k8s cluster in the cloud of your choice.  For example, on GCP:</p> <pre><code>gcloud container clusters create my-istio-cluster \\\n  --cluster-version latest \\\n  --machine-type \"e2-standard-2\" \\\n  --num-nodes \"3\" \\\n  --network \"default\"\n</code></pre>"},{"location":"setup/#environment-variables","title":"Environment variables","text":"<p>Use <code>envrc-template.sh</code> as the basis for configuring environment variables.</p> <p>Be sure to:</p> <ol> <li>Set the local variable <code>local_setup</code> to either \"true\" or \"false\", depending on your choice of a local or remote cluster.</li> <li>If using a remote setup, set the value of PUSH_IMAGE_REGISTRY to the value of your image registry URL.</li> </ol> <p>I highly recommend using <code>direnv</code>, a convenient way of associating setting environment variables with a specific directory.</p> <p>If you choose to use <code>direnv</code>, then the variables can be automatically set by renaming the file to <code>.envrc</code> and running the command <code>direnv allow</code>.</p>"},{"location":"setup/#istio","title":"Istio","text":"<ol> <li> <p>Follow the Istio documentation's instructions to download Istio.</p> </li> <li> <p>After you have added the <code>istioctl</code> CLI to your PATH, run the following installation command:</p> <pre><code>istioctl install -f manifests/istio-install-manifest.yaml\n</code></pre> </li> </ol> <p>The above-referenced configuration manifest configures certain facets of the mesh, namely:</p> <ol> <li>Setting trace sampling at 100%, for ease of obtaining distributed traces</li> <li>Deploying sidecars (envoy proxies) not only alongside workloads, but also in front of mysql databases.</li> </ol> <p>Once Istio is installed, feel free to verify the installation with:</p> <pre><code>istioctl verify-install\n</code></pre> <p>In the next section, you will work on deploying the microservices to the <code>default</code> namespace.</p> <p>As a final step, label the <code>default</code> namespace for sidecar injection with:</p> <pre><code>kubectl label ns default istio-injection=enabled\n</code></pre>"}]}